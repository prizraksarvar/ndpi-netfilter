--- /home/chrisn/src/ndpi-netfilter/nDPI//src/lib/ndpi_main.c	2022-07-26 17:01:48.392842395 -0400
+++ /home/chrisn/src/ndpi-netfilter/nDPI-patch//src/lib/ndpi_main.c	2022-07-25 10:59:27.871051744 -0400
@@ -21,10 +21,6 @@
  *
  */
 
-#include <stdlib.h>
-#include <errno.h>
-#include <sys/types.h>
-
 #define NDPI_CURRENT_PROTO NDPI_PROTOCOL_UNKNOWN
 
 #include "ndpi_config.h"
@@ -32,24 +28,38 @@
 #include "ahocorasick.h"
 #include "libcache.h"
 
-#ifdef HAVE_LIBGCRYPT
+#if defined(HAVE_LIBGCRYPT) && !defined(__KERNEL__)
 #include <gcrypt.h>
 #endif
 
-#include <time.h>
-#ifndef WIN32
-#include <unistd.h>
-#endif
-
-#if defined __FreeBSD__ || defined __NetBSD__ || defined __OpenBSD__
-#include <sys/endian.h>
-#endif
+#include <linux/version.h>
+#define printf printk
 
 #include "ndpi_content_match.c.inc"
 #include "ndpi_azure_match.c.inc"
 #include "third_party/include/ndpi_patricia.h"
 #include "third_party/include/ndpi_md5.h"
 
+extern int atoi(const char *str) {
+  int rc;
+
+  if (kstrtoint(str, 0, &rc) == 0 /* Success */)
+    return(rc);
+  else
+    return(0);
+}
+
+// http://lkml.iu.edu/hypermail/linux/kernel/0303.2/2007.html
+static unsigned int inet_addr(char *str)
+{
+  int a,b,c,d;
+  char arr[4];
+  sscanf(str,"%d.%d.%d.%d",&a,&b,&c,&d);
+  arr[0] = a; arr[1] = b; arr[2] = c; arr[3] = d;
+  return *(unsigned int*)arr;
+}
+
+
 static int _ndpi_debug_callbacks = 0;
 
 /* #define DGA_DEBUG 1 */
@@ -67,56 +77,6 @@
 
 /* ****************************************** */
 
-static ndpi_risk_info ndpi_known_risks[] = {
-  { NDPI_NO_RISK,                               NDPI_RISK_LOW,    CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_URL_POSSIBLE_XSS,                      NDPI_RISK_SEVERE, CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_URL_POSSIBLE_SQL_INJECTION,            NDPI_RISK_SEVERE, CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_URL_POSSIBLE_RCE_INJECTION,            NDPI_RISK_SEVERE, CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_BINARY_APPLICATION_TRANSFER,           NDPI_RISK_SEVERE, CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT,   NDPI_RISK_MEDIUM, CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_TLS_SELFSIGNED_CERTIFICATE,            NDPI_RISK_HIGH,   CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_TLS_OBSOLETE_VERSION,                  NDPI_RISK_HIGH,   CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_TLS_WEAK_CIPHER,                       NDPI_RISK_HIGH,   CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_TLS_CERTIFICATE_EXPIRED,               NDPI_RISK_HIGH,   CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_TLS_CERTIFICATE_MISMATCH,              NDPI_RISK_HIGH,   CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_HTTP_SUSPICIOUS_USER_AGENT,            NDPI_RISK_HIGH,   CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_HTTP_NUMERIC_IP_HOST,                  NDPI_RISK_LOW,    CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_HTTP_SUSPICIOUS_URL,                   NDPI_RISK_HIGH,   CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_HTTP_SUSPICIOUS_HEADER,                NDPI_RISK_HIGH,   CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_TLS_NOT_CARRYING_HTTPS,                NDPI_RISK_LOW,    CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_SUSPICIOUS_DGA_DOMAIN,                 NDPI_RISK_HIGH,   CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_MALFORMED_PACKET,                      NDPI_RISK_LOW,    CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_SSH_OBSOLETE_CLIENT_VERSION_OR_CIPHER, NDPI_RISK_HIGH,   CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_SSH_OBSOLETE_SERVER_VERSION_OR_CIPHER, NDPI_RISK_MEDIUM, CLIENT_LOW_RISK_PERCENTAGE  },
-  { NDPI_SMB_INSECURE_VERSION,                  NDPI_RISK_HIGH,   CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_TLS_SUSPICIOUS_ESNI_USAGE,             NDPI_RISK_MEDIUM, CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_UNSAFE_PROTOCOL,                       NDPI_RISK_LOW,    CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_DNS_SUSPICIOUS_TRAFFIC,                NDPI_RISK_HIGH,   CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_TLS_MISSING_SNI,                       NDPI_RISK_MEDIUM, CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_HTTP_SUSPICIOUS_CONTENT,               NDPI_RISK_HIGH,   CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_RISKY_ASN,                             NDPI_RISK_MEDIUM, CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_RISKY_DOMAIN,                          NDPI_RISK_MEDIUM, CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_MALICIOUS_JA3,                         NDPI_RISK_MEDIUM, CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_MALICIOUS_SHA1_CERTIFICATE,            NDPI_RISK_MEDIUM, CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_DESKTOP_OR_FILE_SHARING_SESSION,       NDPI_RISK_LOW,    CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_TLS_UNCOMMON_ALPN,                     NDPI_RISK_MEDIUM, CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_TLS_CERT_VALIDITY_TOO_LONG,            NDPI_RISK_MEDIUM, CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_TLS_SUSPICIOUS_EXTENSION,              NDPI_RISK_HIGH,   CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_TLS_FATAL_ALERT,                       NDPI_RISK_LOW,    CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_SUSPICIOUS_ENTROPY,                    NDPI_RISK_MEDIUM, CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_CLEAR_TEXT_CREDENTIALS,                NDPI_RISK_HIGH,   CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_DNS_LARGE_PACKET,                      NDPI_RISK_MEDIUM, CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_DNS_FRAGMENTED,                        NDPI_RISK_MEDIUM, CLIENT_FAIR_RISK_PERCENTAGE },
-  { NDPI_INVALID_CHARACTERS,                    NDPI_RISK_HIGH,   CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_POSSIBLE_EXPLOIT,                      NDPI_RISK_SEVERE, CLIENT_HIGH_RISK_PERCENTAGE },
-  { NDPI_TLS_CERTIFICATE_ABOUT_TO_EXPIRE,       NDPI_RISK_MEDIUM, CLIENT_LOW_RISK_PERCENTAGE  },
-
-  /* Leave this as last member */
-  { NDPI_MAX_RISK,                              NDPI_RISK_LOW,    CLIENT_FAIR_RISK_PERCENTAGE }
-};
-
-/* ****************************************** */
-
 /* Forward */
 static void addDefaultPort(struct ndpi_detection_module_struct *ndpi_str, ndpi_port_range *range,
                            ndpi_proto_defaults_t *def, u_int8_t customUserProto, ndpi_default_ports_tree_node_t **root,
@@ -152,7 +112,11 @@
 
 void *ndpi_malloc(size_t size) {
   __sync_fetch_and_add(&ndpi_tot_allocated_memory, size);
+#ifndef __KERNEL__
   return(_ndpi_malloc ? _ndpi_malloc(size) : malloc(size));
+#else
+  return(_ndpi_malloc ? _ndpi_malloc(size) : kmalloc(size, GFP_KERNEL));  
+#endif
 }
 
 /* ****************************************** */
@@ -183,7 +147,11 @@
       _ndpi_free(ptr);
   } else {
     if(ptr)
+#ifndef __KERNEL__      
       free(ptr);
+#else
+      kfree(ptr);
+#endif    
   }
 }
 
@@ -329,10 +297,7 @@
 
 void ndpi_set_proto_category(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protoId,
                              ndpi_protocol_category_t protoCategory) {
-  if(!ndpi_is_valid_protoId(protoId))
     return;
-  else
-    ndpi_str->proto_defaults[protoId].protoCategory = protoCategory;
 }
 
 /* ********************************************************************************** */
@@ -482,14 +447,6 @@
 
 void ndpi_default_ports_tree_node_t_walker(const void *node, const ndpi_VISIT which, const int depth) {
   ndpi_default_ports_tree_node_t *f = *(ndpi_default_ports_tree_node_t **) node;
-
-  printf("<%d>Walk on node %s (%u)\n", depth,
-	 which == ndpi_preorder ?
-	 "ndpi_preorder" :
-	 which == ndpi_postorder ?
-	 "ndpi_postorder" :
-	 which == ndpi_endorder ? "ndpi_endorder" : which == ndpi_leaf ? "ndpi_leaf" : "unknown",
-	 f->default_port);
 }
 
 /* ******************************************************************** */
@@ -718,18 +675,6 @@
 
 /* Self check function to be called only for testing purposes */
 void ndpi_self_check_host_match() {
-  u_int32_t i, j;
-
-  for(i = 0; host_match[i].string_to_match != NULL; i++) {
-    for(j = 0; host_match[j].string_to_match != NULL; j++) {
-      if((i != j) && (strcmp(host_match[i].string_to_match, host_match[j].string_to_match) == 0)) {
-	printf("[INTERNAL ERROR]: Duplicate string detected '%s' [id: %u, id %u]\n",
-	       host_match[i].string_to_match, i, j);
-	printf("\nPlease fix host_match[] in ndpi_content_match.c.inc\n");
-	exit(0);
-      }
-    }
-  }
 }
 
 /* ******************************************************************** */
@@ -783,8 +728,6 @@
 
   /* ************************ */
 
-  ndpi_enable_loaded_categories(ndpi_str);
-
 #ifdef MATCH_DEBUG
   // ac_automata_display(ndpi_str->host_automa.ac_automa, 'n');
 #endif
@@ -828,28 +771,6 @@
 /* ******************************************************************** */
 
 static void ndpi_validate_protocol_initialization(struct ndpi_detection_module_struct *ndpi_str) {
-  u_int i, val;
-
-  for(i = 0; i < ndpi_str->ndpi_num_supported_protocols; i++) {
-    if(ndpi_str->proto_defaults[i].protoName == NULL) {
-      NDPI_LOG_ERR(ndpi_str,
-		   "[NDPI] INTERNAL ERROR missing protoName initialization for [protoId=%d]: recovering\n", i);
-    } else {
-      if((i != NDPI_PROTOCOL_UNKNOWN) &&
-	 (ndpi_str->proto_defaults[i].protoCategory == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)) {
-	NDPI_LOG_ERR(ndpi_str,
-		     "[NDPI] INTERNAL ERROR missing category [protoId=%d/%s] initialization: recovering\n", i,
-		     ndpi_str->proto_defaults[i].protoName ? ndpi_str->proto_defaults[i].protoName : "???");
-      }
-    }
-  }
-
-  /* Sanity check for risks initialization */
-  val = (sizeof(ndpi_known_risks) / sizeof(ndpi_risk_info)) - 1;
-  if(val != NDPI_MAX_RISK) {
-    NDPI_LOG_ERR(ndpi_str,  "[NDPI] INTERNAL ERROR Invalid ndpi_known_risks[] initialization [%u != %u]\n", val, NDPI_MAX_RISK);
-    exit(0);
-  }
 }
 
 /* ******************************************************************** */
@@ -2059,10 +1980,11 @@
 */
 int ndpi_load_ipv4_ptree(struct ndpi_detection_module_struct *ndpi_str,
 			 const char *path, u_int16_t protocol_id) {
+  u_int num_loaded = 0;
+#if 0
   char buffer[128], *line, *addr, *cidr, *saveptr;
   FILE *fd;
   int len;
-  u_int num_loaded = 0;
 
   fd = fopen(path, "r");
 
@@ -2100,6 +2022,7 @@
   }
 
   fclose(fd);
+#endif
   return(num_loaded);
 }
 
@@ -2159,7 +2082,11 @@
     }
   }
 
+#ifndef __KERNEL__
   inet_pton(AF_INET, value, &pin);
+#else
+  in4_pton(value, -1, (__u8*)&pin, '\0', NULL);
+#endif
 
   if((node = add_to_ptree(ndpi_str->protocols_ptree, AF_INET, &pin, bits)) != NULL) {
     node->value.u.uv32.user_value = protocol_id, node->value.u.uv32.additional_user_value = htons(port);
@@ -2358,7 +2285,7 @@
   if(prefs & ndpi_enable_ja3_plus)
     ndpi_str->enable_ja3_plus = 1;
 
-#ifdef HAVE_LIBGCRYPT
+#if defined(HAVE_LIBGCRYPT) && !defined(__KERNEL__)
   if(!(prefs & ndpi_dont_init_libgcrypt)) {
     if(!gcry_control (GCRYCTL_INITIALIZATION_FINISHED_P)) {
       const char *gcrypt_ver = gcry_check_version(NULL);
@@ -2382,8 +2309,6 @@
 			 prefs & ndpi_dont_load_tor_hosts); /* Microsoft Azure */
   }
 
-  ndpi_str->ip_risk_mask_ptree = ndpi_patricia_new(32 /* IPv4 */);
-
   NDPI_BITMASK_RESET(ndpi_str->detection_bitmask);
 #ifdef NDPI_ENABLE_DEBUG_MESSAGES
   ndpi_str->user_data = NULL;
@@ -2403,7 +2328,7 @@
   ndpi_str->ndpi_num_custom_protocols = 0;
 
   ndpi_str->host_automa.ac_automa = ac_automata_init(ac_domain_match_handler);
-  ndpi_str->host_risk_mask_automa.ac_automa = ac_automata_init(ac_domain_match_handler);
+  ndpi_str->host_risk_mask_automa.ac_automa = NULL;
   ndpi_str->common_alpns_automa.ac_automa = ac_automata_init(ac_domain_match_handler);
   load_common_alpns(ndpi_str);
   ndpi_str->tls_cert_subject_automa.ac_automa = ac_automata_init(NULL);
@@ -2436,9 +2361,6 @@
   if(ndpi_str->tls_cert_subject_automa.ac_automa)
     ac_automata_feature(ndpi_str->tls_cert_subject_automa.ac_automa,AC_FEATURE_LC);
 
-  if(ndpi_str->host_risk_mask_automa.ac_automa)
-    ac_automata_feature(ndpi_str->host_risk_mask_automa.ac_automa,AC_FEATURE_LC);
-
   if(ndpi_str->common_alpns_automa.ac_automa)
     ac_automata_feature(ndpi_str->common_alpns_automa.ac_automa,AC_FEATURE_LC);
 
@@ -2456,9 +2378,6 @@
   if(ndpi_str->tls_cert_subject_automa.ac_automa)
     ac_automata_name(ndpi_str->tls_cert_subject_automa.ac_automa,"tls_cert",AC_FEATURE_DEBUG);
 
-  if(ndpi_str->host_risk_mask_automa.ac_automa)
-    ac_automata_name(ndpi_str->host_risk_mask_automa.ac_automa,"content",AC_FEATURE_DEBUG);
-
   if(ndpi_str->common_alpns_automa.ac_automa)
     ac_automata_name(ndpi_str->common_alpns_automa.ac_automa,"content",AC_FEATURE_DEBUG);
 
@@ -2478,47 +2397,9 @@
 
 /* *********************************************** */
 
-/*
-  This function adds some exceptions for popular domain names
-  in order to avoid "false" positives and avoid polluting
-  results
-*/
-static void ndpi_add_domain_risk_exceptions(struct ndpi_detection_module_struct *ndpi_str) {
-  const char *domains[] = {
-    ".local",
-    ".msftconnecttest.com",
-    "amupdatedl.microsoft.com",
-    "update.microsoft.com.akadns.net",
-    ".windowsupdate.com",
-    ".ras.microsoft.com",
-    "e5.sk",
-    "sophosxl.net",
-    NULL /* End */
-  };
-  const ndpi_risk risks_to_mask[] = {
-    NDPI_SUSPICIOUS_DGA_DOMAIN,
-    NDPI_BINARY_APPLICATION_TRANSFER,
-    NDPI_HTTP_NUMERIC_IP_HOST,
-    NDPI_MALICIOUS_JA3,
-    NDPI_NO_RISK /* End */
-  };
-  u_int i;
-  ndpi_risk mask = ((ndpi_risk)-1);
-
-  for(i=0; risks_to_mask[i] != NDPI_NO_RISK; i++)
-    mask &= ~(1ULL << risks_to_mask[i]);
-
-  for(i=0; domains[i] != NULL; i++)
-    ndpi_add_host_risk_mask(ndpi_str, (char*)domains[i], mask);
-}
-
-/* *********************************************** */
-
 void ndpi_finalize_initialization(struct ndpi_detection_module_struct *ndpi_str) {
   u_int i;
 
-  ndpi_add_domain_risk_exceptions(ndpi_str);
-
   if(ndpi_str->ac_automa_finalized) return;
 
   for(i = 0; i < 99; i++) {
@@ -2542,7 +2423,6 @@
       break;
 
     case 4:
-      automa = &ndpi_str->host_risk_mask_automa;
       break;
 
     case 5:
@@ -2716,7 +2596,12 @@
   if(ptr)
     ptr[0] = '\0';
 
-  if(inet_pton(AF_INET, ipbuf, &pin) == 1) {
+#ifndef __KERNEL__
+  int i = inet_pton(AF_INET, ipbuf, &pin);
+#else
+  int i = in4_pton(ipbuf, -1, (__u8*)&pin, '\0', NULL);
+#endif
+  if(i == 1) {
     /* Search IP */
     ndpi_prefix_t prefix;
     ndpi_patricia_node_t *node;
@@ -2785,9 +2670,6 @@
     if(ndpi_str->protocols_ptree)
       ndpi_patricia_destroy((ndpi_patricia_tree_t *) ndpi_str->protocols_ptree, free_ptree_data);
 
-    if(ndpi_str->ip_risk_mask_ptree)
-      ndpi_patricia_destroy((ndpi_patricia_tree_t *) ndpi_str->ip_risk_mask_ptree, free_ptree_data);
-
     if(ndpi_str->udpRoot != NULL)
       ndpi_tdestroy(ndpi_str->udpRoot, ndpi_free);
     if(ndpi_str->tcpRoot != NULL)
@@ -2797,10 +2679,6 @@
       ac_automata_release((AC_AUTOMATA_t *) ndpi_str->host_automa.ac_automa,
 			  1 /* free patterns strings memory */);
 
-    if(ndpi_str->risky_domain_automa.ac_automa != NULL)
-      ac_automata_release((AC_AUTOMATA_t *) ndpi_str->risky_domain_automa.ac_automa,
-                          1 /* free patterns strings memory */);
-
     if(ndpi_str->tls_cert_subject_automa.ac_automa != NULL)
       ac_automata_release((AC_AUTOMATA_t *) ndpi_str->tls_cert_subject_automa.ac_automa, 0);
 
@@ -2826,10 +2704,6 @@
     if(ndpi_str->custom_categories.ipAddresses_shadow != NULL)
       ndpi_patricia_destroy((ndpi_patricia_tree_t *) ndpi_str->custom_categories.ipAddresses_shadow, free_ptree_data);
 
-    if(ndpi_str->host_risk_mask_automa.ac_automa != NULL)
-      ac_automata_release((AC_AUTOMATA_t *) ndpi_str->host_risk_mask_automa.ac_automa,
-			  1 /* free patterns strings memory */);
-
     if(ndpi_str->common_alpns_automa.ac_automa != NULL)
       ac_automata_release((AC_AUTOMATA_t *) ndpi_str->common_alpns_automa.ac_automa,
 			  1 /* free patterns strings memory */);
@@ -2940,28 +2814,11 @@
       break;
     case NDPI_ICMP_PROTOCOL_TYPE:
       if(flow) {
-        flow->entropy = 0.0f;
 	/* Run some basic consistency tests */
 
-	if(packet->payload_packet_len < sizeof(struct ndpi_icmphdr))
-	  ndpi_set_risk(ndpi_str, flow, NDPI_MALFORMED_PACKET);
-	else {
+	if(packet->payload_packet_len >= sizeof(struct ndpi_icmphdr)){
 	  u_int8_t icmp_type = (u_int8_t)packet->payload[0];
 	  u_int8_t icmp_code = (u_int8_t)packet->payload[1];
-
-	  /* https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml */
-	  if(((icmp_type >= 44) && (icmp_type <= 252))
-	     || (icmp_code > 15))
-	    ndpi_set_risk(ndpi_str, flow, NDPI_MALFORMED_PACKET);
-
-	  if (packet->payload_packet_len > sizeof(struct ndpi_icmphdr)) {
-	    flow->entropy = ndpi_entropy(packet->payload + sizeof(struct ndpi_icmphdr),
-	                                 packet->payload_packet_len - sizeof(struct ndpi_icmphdr));
-
-	    if (NDPI_ENTROPY_ENCRYPTED_OR_RANDOM(flow->entropy) != 0) {
-	      ndpi_set_risk(ndpi_str, flow, NDPI_SUSPICIOUS_ENTROPY);
-	    }
-	  }
 	}
       }
       return(NDPI_PROTOCOL_IP_ICMP);
@@ -2985,16 +2842,9 @@
       if(flow) {
 	/* Run some basic consistency tests */
 
-	if(packet->payload_packet_len < sizeof(struct ndpi_icmphdr))
-	  ndpi_set_risk(ndpi_str, flow, NDPI_MALFORMED_PACKET);
-	else {
+	if(packet->payload_packet_len >= sizeof(struct ndpi_icmphdr)){
 	  u_int8_t icmp6_type = (u_int8_t)packet->payload[0];
 	  u_int8_t icmp6_code = (u_int8_t)packet->payload[1];
-
-	  /* https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol_for_IPv6 */
-	  if(((icmp6_type >= 5) && (icmp6_type <= 127))
-	     || ((icmp6_code >= 156) && (icmp6_type != 255)))
-	    ndpi_set_risk(ndpi_str, flow, NDPI_MALFORMED_PACKET);
 	}
       }
       return(NDPI_PROTOCOL_IP_ICMPV6);
@@ -3032,82 +2882,6 @@
 
 /* ******************************************************************** */
 
-int ndpi_add_ip_risk_mask(struct ndpi_detection_module_struct *ndpi_str,
-			  char *ip, ndpi_risk mask) {
-  char *saveptr, *addr = strtok_r(ip, "/", &saveptr);
-
-  if(addr) {
-    char *cidr = strtok_r(NULL, "\n", &saveptr);
-    struct in_addr pin;
-    ndpi_patricia_node_t *node;
-
-    pin.s_addr = inet_addr(addr);
-    /* FIX: Add IPv6 support */
-    if((node = add_to_ptree(ndpi_str->ip_risk_mask_ptree, AF_INET,
-			    &pin, cidr ? atoi(cidr) : 32 /* bits */)) != NULL) {
-      node->value.u.uv64 = (u_int64_t)mask;
-      return(0);
-    } else
-      return(-1);
-  } else
-    return(-2);
-}
-
-/* ******************************************************************** */
-
-int ndpi_add_host_risk_mask(struct ndpi_detection_module_struct *ndpi_str,
-			    char *host, ndpi_risk mask) {
-  AC_PATTERN_t ac_pattern;
-  AC_ERROR_t rc;
-  u_int len;
-  char *host_dup = NULL;
-
-  if((ndpi_str->host_risk_mask_automa.ac_automa == NULL) || (host == NULL))
-    return(-2);
-
-  /* Zap heading/trailing quotes */
-  switch(host[0]) {
-  case '"':
-  case '\'':
-    {
-      int len;
-
-      host = &host[1];
-      len = strlen(host);
-      if(len > 0)
-	host[len-1] = '\0';
-    }
-
-    break;
-  }
-
-  host_dup = ndpi_strdup(host);
-  if(!host_dup)
-    return(-1);
-
-  memset(&ac_pattern, 0, sizeof(ac_pattern));
-
-  len = strlen(host);
-
-  ac_pattern.astring      = host_dup;
-  ac_pattern.length       = len;
-  ac_pattern.rep.number64 = (ndpi_risk)mask;
-  ac_pattern.rep.level    = ndpi_domain_level(host);
-  ac_pattern.rep.at_end   = 0;
-  ac_pattern.rep.dot      = memchr(host,'.',len) != NULL;
-
-  rc = ac_automata_add(ndpi_str->host_risk_mask_automa.ac_automa, &ac_pattern);
-
-  if(rc != ACERR_SUCCESS) {
-    ndpi_free(host_dup);
-
-    if(rc != ACERR_DUPLICATE_PATTERN)
-      return (-2);
-  }
-
-  return(0);
-}
-
 /* ******************************************************************** */
 
 int ndpi_add_trusted_issuer_dn(struct ndpi_detection_module_struct *ndpi_str, char *dn) {
@@ -3128,9 +2902,9 @@
     if((quote = strchr(buf, '"')) != NULL)
       quote[0] = '\0';
 
-    head->value = strdup(buf);
+    head->value = ndpi_strdup(buf);
   } else
-    head->value = strdup(dn);
+    head->value = ndpi_strdup(dn);
 
   if(head->value == NULL) {
     ndpi_free(head);
@@ -3142,478 +2916,6 @@
 
   return(0);
 }
-/* ******************************************************************** */
-
-int ndpi_handle_rule(struct ndpi_detection_module_struct *ndpi_str, char *rule, u_int8_t do_add) {
-  char *at, *proto, *elem;
-  ndpi_proto_defaults_t *def;
-  u_int subprotocol_id, i;
-
-  at = strrchr(rule, '@');
-  if(at == NULL) {
-    /* This looks like a mask rule or an invalid rule */
-    char _rule[256], *rule_type, *key;
-
-    snprintf(_rule, sizeof(_rule), "%s", rule);
-    rule_type = strtok(rule, ":");
-
-    if(!rule_type) {
-      NDPI_LOG_ERR(ndpi_str, "Invalid rule '%s'\n", rule);
-      return(-1);
-    }
-
-    if(!strcmp(rule_type, "trusted_issuer_dn"))
-      return(ndpi_add_trusted_issuer_dn(ndpi_str, strtok(NULL, ":")));
-
-    key = strtok(NULL, "=");
-    if(key) {
-      char *value = strtok(NULL, "=");
-
-      if(value) {
-	ndpi_risk risk_mask = (ndpi_risk)atoll(value);
-
-	if(!strcmp(rule_type, "ip_risk_mask")) {
-	  return(ndpi_add_ip_risk_mask(ndpi_str, key, risk_mask));
-	} else if(!strcmp(rule_type, "host_risk_mask")) {
-	  return(ndpi_add_host_risk_mask(ndpi_str, key, risk_mask));
-	}
-      }
-    }
-
-    NDPI_LOG_ERR(ndpi_str, "Unknown rule '%s'\n", rule);
-    return(-1);
-  } else
-    at[0] = 0, proto = &at[1];
-
-  for(i = 0; proto[i] != '\0'; i++) {
-    switch(proto[i]) {
-    case '/':
-    case '&':
-    case '^':
-    case ':':
-    case ';':
-    case '\'':
-    case '"':
-    case ' ':
-      proto[i] = '_';
-      break;
-    }
-  }
-
-  for(i = 0, def = NULL; i < ndpi_str->ndpi_num_supported_protocols; i++) {
-    if(ndpi_str->proto_defaults[i].protoName
-       && strcasecmp(ndpi_str->proto_defaults[i].protoName, proto) == 0) {
-      def = &ndpi_str->proto_defaults[i];
-      subprotocol_id = i;
-      break;
-    }
-  }
-
-  if(def == NULL) {
-    if(!do_add) {
-      /* We need to remove a rule */
-      NDPI_LOG_ERR(ndpi_str, "Unable to find protocol '%s': skipping rule '%s'\n", proto, rule);
-      return(-3);
-    } else {
-      ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];
-
-      if(ndpi_str->ndpi_num_custom_protocols >= (NDPI_MAX_NUM_CUSTOM_PROTOCOLS - 1)) {
-	NDPI_LOG_ERR(ndpi_str, "Too many protocols defined (%u): skipping protocol %s\n",
-		     ndpi_str->ndpi_num_custom_protocols, proto);
-	return(-2);
-      }
-
-      ndpi_set_proto_defaults(ndpi_str, 1, NDPI_PROTOCOL_ACCEPTABLE,
-			      ndpi_str->ndpi_num_supported_protocols, proto,
-			      NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, /* TODO add protocol category support in rules */
-			      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,
-			      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);
-      def = &ndpi_str->proto_defaults[ndpi_str->ndpi_num_supported_protocols];
-      subprotocol_id = ndpi_str->ndpi_num_supported_protocols;
-      ndpi_str->ndpi_num_supported_protocols++, ndpi_str->ndpi_num_custom_protocols++;
-    }
-  }
-
-  while((elem = strsep(&rule, ",")) != NULL) {
-    char *attr = elem, *value = NULL;
-    ndpi_port_range range;
-    int is_tcp = 0, is_udp = 0, is_ip = 0;
-
-    if(strncmp(attr, "tcp:", 4) == 0)
-      is_tcp = 1, value = &attr[4];
-    else if(strncmp(attr, "udp:", 4) == 0)
-      is_udp = 1, value = &attr[4];
-    else if(strncmp(attr, "ip:", 3) == 0)
-      is_ip = 1, value = &attr[3];
-    else if(strncmp(attr, "host:", 5) == 0) {
-      /* host:"<value>",host:"<value>",.....@<subproto> */
-      u_int i, max_len;
-
-      value = &attr[5];
-      if(value[0] == '"')
-	value++; /* remove leading " */
-
-      max_len = strlen(value) - 1;
-      if(value[max_len] == '"')
-	value[max_len] = '\0'; /* remove trailing " */
-
-      for(i=0; i<max_len; i++) value[i] = tolower(value[i]);
-    }
-
-    if(is_tcp || is_udp) {
-      u_int p_low, p_high;
-
-      if(sscanf(value, "%u-%u", &p_low, &p_high) == 2)
-	range.port_low = p_low, range.port_high = p_high;
-      else
-	range.port_low = range.port_high = atoi(&elem[4]);
-
-      if(do_add)
-	addDefaultPort(ndpi_str, &range, def, 1 /* Custom user proto */,
-		       is_tcp ? &ndpi_str->tcpRoot : &ndpi_str->udpRoot, __FUNCTION__, __LINE__);
-      else
-	removeDefaultPort(&range, def, is_tcp ? &ndpi_str->tcpRoot : &ndpi_str->udpRoot);
-    } else if(is_ip) {
-      /* NDPI_PROTOCOL_TOR */
-      ndpi_add_host_ip_subprotocol(ndpi_str, value, subprotocol_id);
-    } else {
-      if(do_add)
-	ndpi_add_host_url_subprotocol(ndpi_str, value, subprotocol_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,
-				      NDPI_PROTOCOL_ACCEPTABLE, 0);
-      else
-	ndpi_remove_host_url_subprotocol(ndpi_str, value, subprotocol_id);
-    }
-  }
-
-  return(0);
-}
-
-/* ******************************************************************** */
-
-/*
- * Format:
- *
- * <host|ip>	<category_id>
- *
- * Notes:
- *  - host and category are separated by a single TAB
- *  - empty lines or lines starting with # are ignored
- */
-int ndpi_load_categories_file(struct ndpi_detection_module_struct *ndpi_str, const char *path) {
-  char buffer[512], *line, *name, *category, *saveptr;
-  FILE *fd;
-  int len, num = 0;
-
-  fd = fopen(path, "r");
-
-  if(fd == NULL) {
-    NDPI_LOG_ERR(ndpi_str, "Unable to open file %s [%s]\n", path, strerror(errno));
-    return(-1);
-  }
-
-  while(1) {
-    line = fgets(buffer, sizeof(buffer), fd);
-
-    if(line == NULL)
-      break;
-
-    len = strlen(line);
-
-    if((len <= 1) || (line[0] == '#'))
-      continue;
-
-    line[len - 1] = '\0';
-    name = strtok_r(line, "\t", &saveptr);
-
-    if(name) {
-      category = strtok_r(NULL, "\t", &saveptr);
-
-      if(category) {
-	int rc = ndpi_load_category(ndpi_str, name, (ndpi_protocol_category_t) atoi(category));
-
-	if(rc >= 0)
-	  num++;
-      }
-    }
-  }
-
-  fclose(fd);
-  ndpi_enable_loaded_categories(ndpi_str);
-
-  return(num);
-}
-
-/* ******************************************************************** */
-
-static int ndpi_load_risky_domain(struct ndpi_detection_module_struct *ndpi_str,
-				  char* domain_name) {
-  if(ndpi_str->risky_domain_automa.ac_automa == NULL) {
-    ndpi_str->risky_domain_automa.ac_automa = ac_automata_init(ac_domain_match_handler);
-    if(!ndpi_str->risky_domain_automa.ac_automa) return -1;
-    ac_automata_feature(ndpi_str->risky_domain_automa.ac_automa,AC_FEATURE_LC);
-    ac_automata_name(ndpi_str->risky_domain_automa.ac_automa, "risky", 0);
-  }
-
-  if(!ndpi_str->risky_domain_automa.ac_automa)
-    return -1;
-
-  return ndpi_string_to_automa(ndpi_str, (AC_AUTOMATA_t *)ndpi_str->risky_domain_automa.ac_automa,
-			       domain_name, 1, 0, 0, 0, 1); /* domain, protocol, category, breed, level , at_end */
-}
-
-/* ******************************************************************** */
-
-/*
- * Format:
- *
- * <domain name>
- *
- * Notes:
- *  - you can add a .<domain name> to avoid mismatches
- */
-int ndpi_load_risk_domain_file(struct ndpi_detection_module_struct *ndpi_str, const char *path) {
-  char buffer[128], *line;
-  FILE *fd;
-  int len, num = 0;
-
-  fd = fopen(path, "r");
-
-  if(fd == NULL) {
-    NDPI_LOG_ERR(ndpi_str, "Unable to open file %s [%s]\n", path, strerror(errno));
-    return(-1);
-  }
-
-  while(1) {
-    line = fgets(buffer, sizeof(buffer), fd);
-
-    if(line == NULL)
-      break;
-
-    len = strlen(line);
-
-    if((len <= 1) || (line[0] == '#'))
-      continue;
-
-    line[len - 1] = '\0';
-
-    if(ndpi_load_risky_domain(ndpi_str, line) >= 0)
-      num++;
-  }
-
-  fclose(fd);
-
-  if(ndpi_str->risky_domain_automa.ac_automa)
-    ac_automata_finalize((AC_AUTOMATA_t *)ndpi_str->risky_domain_automa.ac_automa);
-
-  return(num);
-}
-
-/* ******************************************************************** */
-
-/*
- * Format:
- *
- * <ja3 hash>[,<other info>]
- *
- */
-int ndpi_load_malicious_ja3_file(struct ndpi_detection_module_struct *ndpi_str, const char *path) {
-  char buffer[128], *line, *str;
-  FILE *fd;
-  int len, num = 0;
-
-  if(ndpi_str->malicious_ja3_automa.ac_automa == NULL)
-    ndpi_str->malicious_ja3_automa.ac_automa = ac_automata_init(NULL);
-  if(ndpi_str->malicious_ja3_automa.ac_automa)
-    ac_automata_name(ndpi_str->malicious_ja3_automa.ac_automa,"ja3",0);
-
-  fd = fopen(path, "r");
-
-  if(fd == NULL) {
-    NDPI_LOG_ERR(ndpi_str, "Unable to open file %s [%s]\n", path, strerror(errno));
-    return(-1);
-  }
-
-  while(1) {
-    char *comma;
-
-    line = fgets(buffer, sizeof(buffer), fd);
-
-    if(line == NULL)
-      break;
-
-    len = strlen(line);
-
-    if((len <= 1) || (line[0] == '#'))
-      continue;
-
-    line[len - 1] = '\0';
-
-    if((comma = strchr(line, ',')) != NULL)
-      comma[0] = '\0';
-
-    str = ndpi_strdup(line);
-    if (str == NULL) {
-      NDPI_LOG_ERR(ndpi_str, "Memory allocation failure\n");
-      return -1;
-    };
-
-    if(ndpi_add_string_to_automa(ndpi_str->malicious_ja3_automa.ac_automa, str) >= 0)
-      num++;
-  }
-
-  fclose(fd);
-
-  return(num);
-}
-
-/* ******************************************************************** */
-
-/*
- * Format:
- *
- * <sha1 hash>
- * <other info>,<sha1 hash>
- * <other info>,<sha1 hash>[,<other info>[...]]
- *
- */
-int ndpi_load_malicious_sha1_file(struct ndpi_detection_module_struct *ndpi_str, const char *path)
-{
-  char buffer[128];
-  char *first_comma, *second_comma, *str;
-  FILE *fd;
-  size_t i, len;
-  int num = 0;
-
-  if (ndpi_str->malicious_sha1_automa.ac_automa == NULL)
-    ndpi_str->malicious_sha1_automa.ac_automa = ac_automata_init(NULL);
-  if(ndpi_str->malicious_sha1_automa.ac_automa)
-    ac_automata_name(ndpi_str->malicious_sha1_automa.ac_automa,"sha1",0);
-
-  fd = fopen(path, "r");
-
-  if (fd == NULL) {
-    NDPI_LOG_ERR(ndpi_str, "Unable to open file %s [%s]\n", path, strerror(errno));
-    return -1;
-  }
-
-  while (fgets(buffer, sizeof(buffer), fd) != NULL) {
-    len = strlen(buffer);
-
-    if (len <= 1 || buffer[0] == '#')
-      continue;
-
-    first_comma = strchr(buffer, ',');
-    if (first_comma != NULL) {
-      first_comma++;
-      second_comma = strchr(first_comma, ',');
-      if (second_comma == NULL)
-        second_comma = &buffer[len - 1];
-    } else {
-      first_comma = &buffer[0];
-      second_comma = &buffer[len - 1];
-    }
-
-    if ((second_comma - first_comma) != 40)
-      continue;
-    second_comma[0] = '\0';
-
-    for (i = 0; i < 40; ++i)
-      first_comma[i] = toupper(first_comma[i]);
-
-    str = ndpi_strdup(first_comma);
-    if (str == NULL) {
-      NDPI_LOG_ERR(ndpi_str, "Memory allocation failure\n");
-      return -1;
-    };
-
-    if (ndpi_add_string_to_automa(ndpi_str->malicious_sha1_automa.ac_automa, str) >= 0)
-      num++;
-  }
-
-  return num;
-}
-
-/* ******************************************************************** */
-
-/*
-  Format:
-  <tcp|udp>:<port>,<tcp|udp>:<port>,.....@<proto>
-
-  Subprotocols Format:
-  host:"<value>",host:"<value>",.....@<subproto>
-
-  IP based Subprotocols Format (<value> is IP or CIDR):
-  ip:<value>,ip:<value>,.....@<subproto>
-
-  Example:
-  tcp:80,tcp:3128@HTTP
-  udp:139@NETBIOS
-
-*/
-int ndpi_load_protocols_file(struct ndpi_detection_module_struct *ndpi_str, const char *path) {
-  FILE *fd;
-  char *buffer, *old_buffer;
-  int chunk_len = 1024, buffer_len = chunk_len, old_buffer_len;
-  int i, rc = -1;
-
-  fd = fopen(path, "r");
-
-  if(fd == NULL) {
-    NDPI_LOG_ERR(ndpi_str, "Unable to open file %s [%s]\n", path, strerror(errno));
-    goto error;
-  }
-
-  buffer = ndpi_malloc(buffer_len);
-
-  if(buffer == NULL) {
-    NDPI_LOG_ERR(ndpi_str, "Memory allocation failure\n");
-    goto close_fd;
-  }
-
-  while(1) {
-    char *line = buffer;
-    int line_len = buffer_len;
-
-    while((line = fgets(line, line_len, fd)) != NULL && line[strlen(line) - 1] != '\n') {
-      i = strlen(line);
-      old_buffer = buffer;
-      old_buffer_len = buffer_len;
-      buffer_len += chunk_len;
-
-      buffer = ndpi_realloc(old_buffer, old_buffer_len, buffer_len);
-
-      if(buffer == NULL) {
-	NDPI_LOG_ERR(ndpi_str, "Memory allocation failure\n");
-	ndpi_free(old_buffer);
-	goto close_fd;
-      }
-
-      line = &buffer[i];
-      line_len = chunk_len;
-    }
-
-    if(!line) /* safety check */
-      break;
-
-    i = strlen(buffer);
-    if((i <= 1) || (buffer[0] == '#'))
-      continue;
-    else
-      buffer[i - 1] = '\0';
-
-    ndpi_handle_rule(ndpi_str, buffer, 1);
-  }
-
-  rc = 0;
-
-  ndpi_free(buffer);
-
- close_fd:
-  fclose(fd);
-
- error:
-  return(rc);
-}
 
 /* ******************************************************************** */
 
@@ -4925,15 +4227,6 @@
 				     ndpi_protocol *ret) {
   /* This function can NOT access &ndpi_str->packet since it is called also from ndpi_detection_giveup() */
 
-#if 0
-  if(flow) {
-    /* Do not go for DNS when there is an application protocol. Example DNS.Apple */
-    if((flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN)
-       && (flow->detected_protocol_stack[0] /* app */ != flow->detected_protocol_stack[1] /* major */))
-      NDPI_CLR_BIT(flow->risk, NDPI_SUSPICIOUS_DGA_DOMAIN);
-  }
-#endif
-
   // printf("====>> %u.%u [%u]\n", ret->master_protocol, ret->app_protocol, flow->detected_protocol_stack[0]);
 
   switch(ret->app_protocol) {
@@ -4980,27 +4273,12 @@
     break;
 
   case NDPI_PROTOCOL_RDP:
-    ndpi_set_risk(ndpi_str, flow, NDPI_DESKTOP_OR_FILE_SHARING_SESSION); /* Remote assistance */
     break;
 
   case NDPI_PROTOCOL_ANYDESK:
-    if(flow->l4_proto == IPPROTO_TCP) /* TCP only */
-      ndpi_set_risk(ndpi_str, flow, NDPI_DESKTOP_OR_FILE_SHARING_SESSION); /* Remote assistance */
     break;
   } /* switch */
 
-  if(flow) {
-    switch(ndpi_get_proto_breed(ndpi_str, ret->app_protocol)) {
-    case NDPI_PROTOCOL_UNSAFE:
-    case NDPI_PROTOCOL_POTENTIALLY_DANGEROUS:
-    case NDPI_PROTOCOL_DANGEROUS:
-      ndpi_set_risk(ndpi_str, flow, NDPI_UNSAFE_PROTOCOL);
-      break;
-    default:
-      /* Nothing to do */
-      break;
-    }
-  }
 }
 
 /* ********************************************************************************* */
@@ -5314,7 +4592,12 @@
       bits = atoi(ptr);
   }
 
-  if(inet_pton(AF_INET, ipbuf, &pin) != 1) {
+#ifndef __KERNEL__
+  int i = inet_pton(AF_INET, ipbuf, &pin);
+#else
+  int i = in4_pton(ipbuf, -1, (__u8*)&pin, '\0', NULL);
+#endif
+  if(i != 1) {
     NDPI_LOG_DBG2(ndpi_str, "Invalid ip/ip+netmask: %s\n", ip_address_and_mask);
     return(-1);
   }
@@ -5733,88 +5016,6 @@
     ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);
   }
 
-#if 0
-  /* See https://github.com/ntop/nDPI/pull/1425 */
-    if((ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) &&
-       (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {
-      ret.master_protocol = ret.app_protocol;
-      ret.app_protocol = flow->guessed_host_protocol_id;
-    }
-#endif
-    
-  if((!flow->risk_checked)
-     && ((ret.master_protocol != NDPI_PROTOCOL_UNKNOWN) || (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))
-     ) {
-    ndpi_default_ports_tree_node_t *found;
-    u_int16_t *default_ports, sport, dport;
-
-    if(packet->udp)
-      found = ndpi_get_guessed_protocol_id(ndpi_str, IPPROTO_UDP,
-					   sport = ntohs(packet->udp->source),
-					   dport = ntohs(packet->udp->dest)),
-	default_ports = ndpi_str->proto_defaults[ret.master_protocol ? ret.master_protocol : ret.app_protocol].udp_default_ports;
-    else if(packet->tcp)
-      found = ndpi_get_guessed_protocol_id(ndpi_str, IPPROTO_TCP,
-					   sport = ntohs(packet->tcp->source),
-					   dport = ntohs(packet->tcp->dest)),
-	default_ports = ndpi_str->proto_defaults[ret.master_protocol ? ret.master_protocol : ret.app_protocol].tcp_default_ports;
-    else
-      found = NULL, default_ports = NULL, sport = dport = 0;
-
-    if(found
-       && (found->proto->protoId != NDPI_PROTOCOL_UNKNOWN)
-       && (found->proto->protoId != ret.master_protocol)
-       && (found->proto->protoId != ret.app_protocol)
-       ) {
-      // printf("******** %u / %u\n", found->proto->protoId, ret.master_protocol);
-
-      if(!ndpi_check_protocol_port_mismatch_exceptions(ndpi_str, flow, found, &ret)) {
-	/*
-	  Before triggering the alert we need to make some extra checks
-	  - the protocol found is not running on the port we have found (i.e. two or more protools share the same default port)
-	*/
-	u_int8_t found = 0, i;
-
-	for(i=0; (i<MAX_DEFAULT_PORTS) && (default_ports[i] != 0); i++) {
-	  if(default_ports[i] == dport) {
-	    found = 1;
-	    break;
-	  }
-	} /* for */
-
-	if(!found)
-	  ndpi_set_risk(ndpi_str, flow, NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT);
-      }
-    } else if((!ndpi_is_ntop_protocol(&ret)) && default_ports && (default_ports[0] != 0)) {
-      u_int8_t found = 0, i, num_loops = 0;
-
-    check_default_ports:
-      for(i=0; (i<MAX_DEFAULT_PORTS) && (default_ports[i] != 0); i++) {
-	if((default_ports[i] == sport) || (default_ports[i] == dport)) {
-	  found = 1;
-	  break;
-	}
-      } /* for */
-
-      if((num_loops == 0) && (!found)) {
-	if(packet->udp)
-	  default_ports = ndpi_str->proto_defaults[ret.app_protocol].udp_default_ports;
-	else
-	  default_ports = ndpi_str->proto_defaults[ret.app_protocol].tcp_default_ports;
-
-	num_loops = 1;
-	goto check_default_ports;
-      }
-
-      if(!found) {
-	// printf("******** Invalid default port\n");
-	ndpi_set_risk(ndpi_str, flow, NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT);
-      }
-    }
-
-    flow->risk_checked = 1;
-  }
-
   ndpi_reconcile_protocols(ndpi_str, flow, &ret);
 
   if(num_calls == 0)
@@ -6584,7 +5785,7 @@
   const u_int8_t *a = (const u_int8_t *) &ip->ipv4;
 
   if(ndpi_is_ipv6(ip)) {
-    if(inet_ntop(AF_INET6, &ip->ipv6.u6_addr, buf, buf_len) == NULL)
+    if(ndpi_inet_ntop(AF_INET6, &ip->ipv6.u6_addr, buf, buf_len) == NULL)
       buf[0] = '\0';
 
     return(buf);
@@ -6603,10 +5804,20 @@
   memset(parsed_ip, 0, sizeof(*parsed_ip));
 
   if(strchr(ip_str, '.')) {
-    if(inet_pton(AF_INET, ip_str, &parsed_ip->ipv4) > 0)
+#ifndef __KERNEL__
+    rv = inet_pton(AF_INET, ip_str, &parsed_ip->ipv4);
+#else
+    rv = in4_pton(ip_str, -1, (__u8*)&parsed_ip->ipv4, '\0', NULL);
+#endif
+    if (rv > 0)
       rv = 4;
   } else {
-    if(inet_pton(AF_INET6, ip_str, &parsed_ip->ipv6) > 0)
+#ifndef __KERNEL__
+    rv = inet_pton(AF_INET6, ip_str, &parsed_ip->ipv6);
+#else
+    rv = in6_pton(ip_str, -1, (__u8*)&parsed_ip->ipv6, '\0', NULL);
+#endif
+    if (rv > 0)
       rv = 6;
   }
 
@@ -6990,86 +6201,6 @@
 
 /* ********************************** */
 
-/* Helper function used to generate Options fields in OPNsense */
-
-void ndpi_generate_options(u_int opt) {
-  struct ndpi_detection_module_struct *ndpi_str;
-  NDPI_PROTOCOL_BITMASK all;
-  u_int i;
-
-  ndpi_str = ndpi_init_detection_module(ndpi_no_prefs);
-
-  NDPI_BITMASK_SET_ALL(all);
-  ndpi_set_protocol_detection_bitmask2(ndpi_str, &all);
-
-  switch(opt) {
-  case 0: /* List known protocols */
-    {
-      for(i = 1 /* Skip unknown */; i < ndpi_str->ndpi_num_supported_protocols; i++) {
-	printf("            <Option%d value=\"%u\">%s</Option%d>\n",
-	       i, i, ndpi_str->proto_defaults[i].protoName, i);
-      }
-    }
-    break;
-
-  case 1: /* List known categories */
-    {
-      for(i = 1 /* Skip Unknown */; i < NDPI_PROTOCOL_NUM_CATEGORIES; i++) {
-	const char *name = ndpi_category_get_name(ndpi_str, i);
-
-	if((name != NULL) && (name[0] != '\0')) {
-	  printf("            <Option%d value=\"%u\">%s</Option%d>\n",
-		 i, i, name, i);
-	}
-      }
-    }
-    break;
-
-  case 2: /* List known risks */
-    {
-      for(i = 1 /* Skip no risk */; i < NDPI_MAX_RISK; i++) {
-	ndpi_risk_enum r = (ndpi_risk_enum)i;
-
-	printf("            <Option%d value=\"%u\">%s</Option%d>\n",
-	       i, i, ndpi_risk2str(r), i);
-      }
-    }
-    break;
-
-  default:
-    printf("WARNING: option -a out of range\n");
-    break;
-  }
-
-  exit(0);
-}
-
-/* ****************************************************** */
-
-void ndpi_dump_risks_score() {
-  u_int i;
-
-  printf("%3s %-48s %-8s %s %-8s %-8s\n",
-	 "Id", "Risk", "Severity", "Score", "CliScore", "SrvScore");
-
-  for(i = 1; i < NDPI_MAX_RISK; i++) {
-    ndpi_risk_enum r = (ndpi_risk_enum)i;
-    ndpi_risk risk   = (uint64_t)2 << (r-1);
-    ndpi_risk_info* info = ndpi_risk2severity(r);
-    ndpi_risk_severity s =info->severity;
-    u_int16_t client_score, server_score;
-    u_int16_t score = ndpi_risk2score(risk, &client_score, &server_score);
-
-    printf("%3d %-48s %-8s %-8u %-8u %-8u\n",
-	   i, ndpi_risk2str(r),
-	   ndpi_severity2str(s),
-	   score,
-	   client_score, server_score);
-  }
-}
-
-/* ****************************************************** */
-
 /*
  * Find the first occurrence of find in s, where the search is limited to the
  * first slen characters of s.
@@ -7225,17 +6356,6 @@
 
 /* ****************************************************** */
 
-void ndpi_check_subprotocol_risk(struct ndpi_detection_module_struct *ndpi_str,
-				 struct ndpi_flow_struct *flow, u_int16_t subprotocol_id) {
-  switch(subprotocol_id) {
-  case NDPI_PROTOCOL_ANYDESK:
-    ndpi_set_risk(ndpi_str, flow, NDPI_DESKTOP_OR_FILE_SHARING_SESSION); /* Remote assistance */
-    break;
-  }
-}
-
-/* ****************************************************** */
-
 u_int16_t ndpi_match_host_subprotocol(struct ndpi_detection_module_struct *ndpi_str,
 				      struct ndpi_flow_struct *flow,
 				      char *string_to_match, u_int string_to_match_len,
@@ -7250,22 +6370,6 @@
 					    master_protocol_id, ret_match);
   id = ret_match->protocol_category;
 
-  if(ndpi_get_custom_category_match(ndpi_str, string_to_match, string_to_match_len, &id) != -1) {
-    /* if(id != -1) */ {
-      flow->category = ret_match->protocol_category = id;
-      rc = master_protocol_id;
-    }
-  }
-
-  if(ndpi_str->risky_domain_automa.ac_automa != NULL) {
-    u_int32_t proto_id;
-    u_int16_t rc1 = ndpi_match_string_common(ndpi_str->risky_domain_automa.ac_automa,
-					     string_to_match,string_to_match_len,
-					     &proto_id, NULL, NULL);
-    if(rc1 > 0)
-      ndpi_set_risk(ndpi_str, flow, NDPI_RISKY_DOMAIN);
-  }
-
   return(rc);
 }
 
@@ -7349,7 +6453,6 @@
   return(0);
 }
 
-#ifdef CODE_UNUSED
 int NDPI_BITMASK_IS_EMPTY(NDPI_PROTOCOL_BITMASK a) {
   unsigned int i;
 
@@ -7360,6 +6463,7 @@
   return(1);
 }
 
+#ifdef CODE_UNUSED
 void NDPI_DUMP_BITMASK(NDPI_PROTOCOL_BITMASK a) {
   unsigned int i;
 
@@ -7375,7 +6479,7 @@
 }
 
 const char *ndpi_get_gcrypt_version(void) {
-#ifdef HAVE_LIBGCRYPT
+#if defined(HAVE_LIBGCRYPT) && !defined(__KERNEL__)
   return gcry_check_version(NULL);
 #endif
   return NULL;
@@ -7757,305 +6861,7 @@
 int ndpi_check_dga_name(struct ndpi_detection_module_struct *ndpi_str,
 			struct ndpi_flow_struct *flow,
 			char *name, u_int8_t is_hostname) {
-  if(ndpi_dga_function != NULL) {
-    /* A custom DGA function is defined */
-    int rc = ndpi_dga_function(name, is_hostname);
-
-    if(rc) {
-      if(flow)
-	ndpi_set_risk(ndpi_str, flow, NDPI_SUSPICIOUS_DGA_DOMAIN);
-    }
-
-    return(rc);
-  } else {
-    int len, rc = 0, trigram_char_skip = 0;
-    u_int8_t max_num_char_repetitions = 0, last_char = 0, num_char_repetitions = 0, num_dots = 0, num_trigram_dots = 0;
-    u_int8_t max_domain_element_len = 0, curr_domain_element_len = 0, first_element_is_numeric = 1;
-    ndpi_protocol_match_result ret_match;
-
-    if((!name)
-       || (strchr(name, '_') != NULL)
-       || (ndpi_ends_with(name, "in-addr.arpa"))
-       || (ndpi_ends_with(name, "ip6.arpa"))
-       /* Ignore TLD .local .lan and .home */
-       || (ndpi_ends_with(name, ".local"))
-       || (ndpi_ends_with(name, ".lan"))
-       || (ndpi_ends_with(name, ".home"))
-       )
-      return(0);
-
-    if(flow && (flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN))
-      return(0); /* Ignore DGA check for protocols already fully detected */
-
-    if(ndpi_match_string_subprotocol(ndpi_str, name, strlen(name), &ret_match) > 0)
-      return(0); /* Ignore DGA for known domain names */
-
-    if(isdigit(name[0])) {
-      struct in_addr ip_addr;
-
-      ip_addr.s_addr = inet_addr(name);
-      if(strcmp(inet_ntoa(ip_addr), name) == 0)
-	return(0); /* Ignore numeric IPs */
-    }
-
-    if(strncmp(name, "www.", 4) == 0)
-      name = &name[4];
-
-    if(ndpi_verbose_dga_detection)
-      printf("[DGA check] %s\n", name);
-
-    len = strlen(name);
-
-    if(len >= 5) {
-      int num_found = 0, num_impossible = 0, num_bigram_checks = 0,
-	num_trigram_found = 0, num_trigram_checked = 0, num_dash = 0,
-	num_digits = 0, num_vowels = 0, num_trigram_vowels = 0, num_words = 0, skip_next_bigram = 0;
-      char tmp[128], *word, *tok_tmp;
-      u_int i, j, max_tmp_len = sizeof(tmp)-1;
-
-      len = snprintf(tmp, max_tmp_len, "%s", name);
-      if(len < 0) {
-
-	if(ndpi_verbose_dga_detection)
-	  printf("[DGA] Too short");
-
-	return(0);
-      } else
-	tmp[(u_int)len < max_tmp_len ? (u_int)len : max_tmp_len] = '\0';
-
-      for(i=0, j=0; (i<(u_int)len) && (j<max_tmp_len); i++) {
-	tmp[j] = tolower(name[i]);
-
-	if(tmp[j] == '.') {
-	  num_dots++;
-	} else if(num_dots == 0) {
-	  if(!isdigit(tmp[j]))
-	    first_element_is_numeric = 0;
-	}
-
-	if(ndpi_is_vowel(tmp[j]))
-	  num_vowels++;
-
-	if(last_char == tmp[j]) {
-	  if(++num_char_repetitions > max_num_char_repetitions)
-	    max_num_char_repetitions = num_char_repetitions;
-	} else
-	  num_char_repetitions = 1, last_char = tmp[j];
-
-	if(isdigit(tmp[j])) {
-	  num_digits++;
-
-	  if(((j+2)<(u_int)len) && isdigit(tmp[j+1]) && (tmp[j+2] == '.')) {
-	    /* Check if there are too many digits */
-	    if(num_digits < 4)
-	      return(0); /* Double digits */
-	  }
-	}
-
-	switch(tmp[j]) {
-	case '.':
-	case '-':
-	case '_':
-	case '/':
-	case ')':
-	case '(':
-	case ';':
-	case ':':
-	case '[':
-	case ']':
-	case ' ':
-	  /*
-	    Domain/word separator chars
-
-	    NOTE:
-	    this function is used also to detect other type of issues
-	    such as invalid/suspiciuous user agent
-	  */
-	  if(curr_domain_element_len > max_domain_element_len)
-	    max_domain_element_len = curr_domain_element_len;
-
-	  curr_domain_element_len = 0;
-	  break;
-
-	default:
-	  curr_domain_element_len++;
-	  break;
-	}
-
-	j++;
-      }
-
-      if(num_dots == 0) /* Doesn't look like a domain name */
-	return(0);
-
-      if(curr_domain_element_len > max_domain_element_len)
-	max_domain_element_len = curr_domain_element_len;
-
-      if(ndpi_verbose_dga_detection)
-	printf("[DGA] [max_num_char_repetitions: %u][max_domain_element_len: %u]\n",
-	       max_num_char_repetitions, max_domain_element_len);
-
-      if(
-	 (is_hostname
-	  && (num_dots > 5)
-	  && (!first_element_is_numeric)
-	  )
-	 || (max_num_char_repetitions > 5 /* num or consecutive repeated chars */)
-	 /*
-	   In case of a name with too many consecutive chars an alert is triggered
-	   This is the case for instance of the wildcard DNS query used by NetBIOS
-	   (ckaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) and that can be exploited
-	   for reflection attacks
-	   - https://www.akamai.com/uk/en/multimedia/documents/state-of-the-internet/ddos-reflection-netbios-name-server-rpc-portmap-sentinel-udp-threat-advisory.pdf
-	   - http://ubiqx.org/cifs/NetBIOS.html
-	 */
-	 || ((max_domain_element_len >= 19 /* word too long. Example bbcbedxhgjmdobdprmen.com */) && ((num_char_repetitions > 1) || (num_digits > 1)))
-	 ) {
-	if(flow) {
-	  ndpi_set_risk(ndpi_str, flow, NDPI_SUSPICIOUS_DGA_DOMAIN);
-	}
-
-	if(ndpi_verbose_dga_detection)
-	  printf("[DGA] Found!");
-
-	return(1);
-      }
-
-      tmp[j] = '\0';
-      len = j;
-
-      for(word = strtok_r(tmp, ".", &tok_tmp); ; word = strtok_r(NULL, ".", &tok_tmp)) {
-	if(!word) break;
-
-	num_words++;
-
-	if(strlen(word) < 3) continue;
-
-	if(ndpi_verbose_dga_detection)
-	  printf("-> word(%s) [%s][len: %u]\n", word, name, (unsigned int)strlen(word));
-
-	trigram_char_skip = 0;
-
-	for(i = 0; word[i+1] != '\0'; i++) {
-	  switch(word[i]) {
-	  case '-':
-	    num_dash++;
-	    /*
-	      Let's check for double+consecutive --
-	      that are usually ok
-	      r2---sn-uxaxpu5ap5-2n5e.gvt1.com
-	    */
-	    if(word[i+1] == '-')
-	      return(0); /* Double dash */
-	    continue;
-
-	  case '_':
-	  case ':':
-	    continue;
-	    break;
-
-	  case '.':
-	    continue;
-	    break;
-	  }
-	  num_bigram_checks++;
-
-	  if(ndpi_verbose_dga_detection)
-	    printf("-> Checking %c%c\n", word[i], word[i+1]);
-
-	  if(ndpi_match_impossible_bigram(&word[i])) {
-	    if(ndpi_verbose_dga_detection)
-	      printf("IMPOSSIBLE %s\n", &word[i]);
-
-	    num_impossible++;
-	  } else {
-	    if(!skip_next_bigram) {
-	      if(ndpi_match_bigram(&word[i])) {
-		num_found++, skip_next_bigram = 1;
-	      }
-	    } else
-	      skip_next_bigram = 0;
-	  }
-
-	  if((num_trigram_dots < 2) && (word[i+2] != '\0')) {
-	    if(ndpi_verbose_dga_detection)
-	      printf("***> %s [trigram_char_skip: %u]\n", &word[i], trigram_char_skip);
-
-	    if(ndpi_is_trigram_char(word[i]) && ndpi_is_trigram_char(word[i+1]) && ndpi_is_trigram_char(word[i+2])) {
-	      if(trigram_char_skip) {
-		trigram_char_skip--;
-	      } else {
-		num_trigram_checked++;
-
-		if(ndpi_match_trigram(&word[i]))
-		  num_trigram_found++, trigram_char_skip = 2 /* 1 char overlap */;
-		else if(ndpi_verbose_dga_detection)
-		  printf("[NDPI] NO Trigram %c%c%c\n", word[i], word[i+1], word[i+2]);
-
-		/* Count vowels */
-		num_trigram_vowels += ndpi_is_vowel(word[i]) + ndpi_is_vowel(word[i+1]) + ndpi_is_vowel(word[i+2]);
-	      }
-	    } else {
-	      if(word[i] == '.')
-		num_trigram_dots++;
-
-	      trigram_char_skip = 0;
-	    }
-	  }
-	} /* for */
-      } /* for */
-
-      if(ndpi_verbose_dga_detection)
-	printf("[%s][num_found: %u][num_impossible: %u][num_digits: %u][num_bigram_checks: %u][num_vowels: %u/%u][num_trigram_vowels: %u][num_trigram_found: %u/%u][vowels: %u][rc: %u]\n",
-	       name, num_found, num_impossible, num_digits, num_bigram_checks, num_vowels, len, num_trigram_vowels,
-	       num_trigram_checked, num_trigram_found, num_vowels, rc);
-
-      if((len > 16) && (num_dots < 3) && ((num_vowels*4) < (len-num_dots))) {
-	if((num_trigram_checked > 2) && (num_trigram_vowels >= (num_trigram_found-1)))
-	  ; /* skip me */
-	else
-	  rc = 1;
-      }
-
-      if(num_bigram_checks
-	 /* We already checked num_dots > 0 */
-	 && ((num_found == 0) || ((num_digits > 5) && (num_words <= 3))
-	     || enough(num_found, num_impossible)
-	     || ((num_trigram_checked > 2)
-		 && ((num_trigram_found < (num_trigram_checked/2))
-		     || ((num_trigram_vowels < (num_trigram_found-1)) && (num_dash == 0) && (num_dots > 1) && (num_impossible > 0)))
-		 )
-	     )
-	 )
-	rc = 1;
-
-      if((num_trigram_checked > 2) && (num_vowels == 0))
-	rc = 1;
-
-      if(num_dash > 2)
-	rc = 0;
-
-      if(ndpi_verbose_dga_detection) {
-	if(rc)
-	  printf("DGA %s [num_found: %u][num_impossible: %u]\n",
-		 name, num_found, num_impossible);
-      }
-    }
-
-    if(ndpi_verbose_dga_detection)
-      printf("[DGA] Result: %u\n", rc);
-
-    if(rc && flow)
-      ndpi_set_risk(ndpi_str, flow, NDPI_SUSPICIOUS_DGA_DOMAIN);
-
-    return(rc);
-  }
-}
-
-/* ******************************************************************** */
-
-ndpi_risk_info* ndpi_risk2severity(ndpi_risk_enum risk) {
-  return(&ndpi_known_risks[risk]);
+  return 0;
 }
 
 /* ******************************************************************** */
